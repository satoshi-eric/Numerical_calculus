{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "#importando bibliotecas\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.optimize import curve_fit\n",
    "from math import *"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "#definição do modelo\n",
    "\"\"\"\n",
    "modelo(V, R)\n",
    "    V: variável\n",
    "    R: parâmetro a ser achado\n",
    "\"\"\"\n",
    "def modelo(V, R):\n",
    "    return (373*R)/ V"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.0820361])"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"\"\"\n",
    "nexp: numero de experimentos\n",
    "x: lista com os valores do eixo x\n",
    "y: lista com valores do eixo y\n",
    "curve_fit(modelo, x, y)\n",
    "    modelo: função com parâmetro a ser achado\n",
    "        a função de deve estar no formato função(variável, parâmetro):\n",
    "    x: variável independente\n",
    "    y: variável dependente de x\n",
    "    popt: parâmetro da função encontrado\n",
    "\"\"\"\n",
    "nexp = 10\n",
    "x = [1., 2., 3., 4., 5., 6., 7., 8., 9., 10]\n",
    "y = [30.6, 15.3, 10.2, 7.65, 6.12, 5.10, 4.37, 3.82, 3.40, 3.06]\n",
    "popt, pcov= curve_fit(modelo, x, y)\n",
    "popt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.collections.PathCollection at 0x189d85f0>"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXAAAAD4CAYAAAD1jb0+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjEsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy8QZhcZAAAOjUlEQVR4nO3df6jdd33H8efLJMOrbtxKryW5lcW5kikr5spFugXEWV06N9ZYJkyYlFGIf+hWh2Q0/qMbg3bEH9sfQ4i2M7CuTmpMxYmx1I4ijI6bpjOtWShz1fUma664O7tx2dL43h/3xDTxxnvuvefc7/nkPh9wued+7rn3vDk0z558vt9vTqoKSVJ7Xtb1AJKk1THgktQoAy5JjTLgktQoAy5Jjdq8ng927bXX1vbt29fzISWpeceOHft+VU1cvr6uAd++fTszMzPr+ZCS1Lwk311q3S0USWqUAZekRhlwSWqUAZekRhlwSWrUup6FshpHjs9y4OgpTs8vsG18jH27d7BnarLrsSSpcyMd8CPHZ9l/+AQL584DMDu/wP7DJwCMuKQNb6S3UA4cPfXjeF+wcO48B46e6mgiSRodIx3w0/MLK1qXpI1k2YAneXmSf0ryz0meTvInvfXXJXk8yTNJ/i7Jzwx6uG3jYytal6SNpJ9X4P8LvL2q3gTsBG5JchPw58CnquoG4D+BOwY93L7dOxjbsumStbEtm9i3e8egH0qSmrNswGvRf/e+3NL7KODtwIO99UPAnkEPt2dqkrtvu5HJ8TECTI6PcfdtN3oAU5Lo8yyUJJuAY8AvAn8F/CswX1Uv9u7yHDCUqu6ZmjTYkrSEvg5iVtX5qtoJXA+8BXjDUndb6meT7E0yk2Rmbm5u9ZNKki6xorNQqmoe+AfgJmA8yYVX8NcDp6/wMwerarqqpicmfuKfs5UkrVI/Z6FMJBnv3R4D3gGcBB4Ffqd3t9uBh4Y1pCTpJ/WzB74VONTbB38Z8IWq+kqSbwOfT/JnwHHg3iHOKUm6zLIBr6pvAVNLrH+Hxf1wSVIHRvpKTEnSlRlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRhlwSWqUAZekRi0b8CSvTfJokpNJnk5yZ2/9Y0lmkzzZ+3jX8MeVJF2wuY/7vAh8uKqeSPKzwLEkD/e+96mq+vjwxpMkXcmyAa+qM8CZ3u0XkpwEJoc9mCTpp1vRHniS7cAU8Hhv6YNJvpXkviTXXOFn9iaZSTIzNze3pmElSRf1HfAkrwK+CHyoqn4IfBp4PbCTxVfon1jq56rqYFVNV9X0xMTEAEaWJEGfAU+yhcV4319VhwGq6vmqOl9VPwI+A7xleGNKki7Xz1koAe4FTlbVJ1+yvvUld3s38NTgx5MkXUk/Z6HsAt4HnEjyZG/tI8B7k+wECngWeP9QJpQkLamfs1C+CWSJb3118ONIkvrllZiS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1KhlA57ktUkeTXIyydNJ7uytvzrJw0me6X2+ZvjjSpIu6OcV+IvAh6vqDcBNwAeSvBG4C3ikqm4AHul9LUlaJ8sGvKrOVNUTvdsvACeBSeBW4FDvboeAPcMaUpL0k1a0B55kOzAFPA5cV1VnYDHywGuu8DN7k8wkmZmbm1vbtJKkH+s74EleBXwR+FBV/bDfn6uqg1U1XVXTExMTq5lRkrSEvgKeZAuL8b6/qg73lp9PsrX3/a3A2eGMKElaSj9noQS4FzhZVZ98ybe+DNzeu3078NDgx5MkXcnmPu6zC3gfcCLJk721jwD3AF9IcgfwPeA9wxlRkrSUZQNeVd8EcoVv3zzYcSRJ/fJKTElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElqlAGXpEYZcElq1OauB2jFkeOzHDh6itPzC2wbH2Pf7h3smZrseixJG5gB78OR47PsP3yChXPnAZidX2D/4RMARlxSZ5bdQklyX5KzSZ56ydrHkswmebL38a7hjtmtA0dP/TjeFyycO8+Bo6c6mkiS+tsD/xxwyxLrn6qqnb2Prw52rNFyen5hReuStB6WDXhVPQb8YB1mGVnbxsdWtC5J62EtZ6F8MMm3elss11zpTkn2JplJMjM3N7eGh+vOvt07GNuy6ZK1sS2b2Ld7R0cTSdLqA/5p4PXATuAM8Ikr3bGqDlbVdFVNT0xMrPLhurVnapK7b7uRyfExAkyOj3H3bTd6AFNSp1Z1FkpVPX/hdpLPAF8Z2EQjas/UpMGWNFJW9Qo8ydaXfPlu4Kkr3VeSNBzLvgJP8gDwNuDaJM8BHwXelmQnUMCzwPuHOKMkaQnLBryq3rvE8r1DmEWStAL+WyiS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmNMuCS1CgDLkmN2tz1AFqZI8dnOXD0FKfnF9g2Psa+3TvYMzXZ9ViSOrDsK/Ak9yU5m+Spl6y9OsnDSZ7pfb5muGMKFuO9//AJZucXKGB2foH9h09w5Phs16NJ6kA/WyifA265bO0u4JGqugF4pPe1huzA0VMsnDt/ydrCufMcOHqqo4kkdWnZgFfVY8APLlu+FTjUu30I2DPgubSE0/MLK1qXdHVb7UHM66rqDEDv82uudMcke5PMJJmZm5tb5cMJYNv42IrWJV3dhn4WSlUdrKrpqpqemJgY9sNd1fbt3sHYlk2XrI1t2cS+3Ts6mkhSl1Z7FsrzSbZW1ZkkW4GzgxxKS7twtolnoUiC1Qf8y8DtwD29zw8NbCL9VHumJg22JKC/0wgfAP4R2JHkuSR3sBjudyZ5Bnhn72tJ0jpa9hV4Vb33Ct+6ecCzSJJWwEvpJalRBlySGmXAJalRBlySGmXAJalRBlySGmXAJalRBlySGuU78mhVfGcgqXsGXCt24Z2BLry5xIV3BgKMuLSO3ELRivnOQNJoMOBaMd8ZSBoNBlwr5jsDSaPBgGvFfGcgaTR4EFMr5jsDSaPBgGtVfGcgqXtuoUhSowy4JDXKgEtSo9wDV7O8nF8bnQFXk7ycX3ILRY3ycn7JgKtRXs4vGXA1ysv5JQOuRnk5v+RBTDXKy/klA66Gjcrl/J7OqK6sKeBJngVeAM4DL1bV9CCGklrh6Yzq0iD2wH+tqnYab21Ens6oLnkQU1oDT2dUl9Ya8AK+nuRYkr1L3SHJ3iQzSWbm5ubW+HDSaPF0RnVprQHfVVVvBn4D+ECSt15+h6o6WFXTVTU9MTGxxoeTRssonc545Pgsu+75Bq+76+/Zdc83OHJ8dt1n0Ppa00HMqjrd+3w2yZeAtwCPDWIwqQWjcjqjB1M3plUHPMkrgZdV1Qu9278O/OnAJpMaMQqnM/60g6ldz6bhWcsr8OuALyW58Hv+tqq+NpCpJK2IB1M3plUHvKq+A7xpgLNIWqVt42PMLhHrLg6memHT+vE0QukqMCoHUy/sxc/OL1Bc3Iv3gOpwGHDpKrBnapK7b7uRyfExAkyOj3H3bTeu+ytfL2xaX/5bKNJVYhQOpo7KXvxG2cbxFbikgRmFC5s20jaOAZc0MKOwF7+RtnHcQpE0MKNwYdOobOPA8LdyDLikgep6L35UTqlcj6tj3UKRdFUZhW0cWJ+tHF+BS7qqjMI2DqzPVo4Bl3TV6XobB9ZnK8ctFEkagvXYyvEVuCQNwXps5RhwSRqSYW/luIUiSY0y4JLUKAMuSY0y4JLUKAMuSY1KVa3fgyVzwHfX7QGH41rg+10PMUJ8Pi7yubiUz8dFa30ufr6qJi5fXNeAXw2SzFTVdNdzjAqfj4t8Li7l83HRsJ4Lt1AkqVEGXJIaZcBX7mDXA4wYn4+LfC4u5fNx0VCeC/fAJalRvgKXpEYZcElqlAHvU5LXJnk0yckkTye5s+uZupZkU5LjSb7S9SxdSzKe5MEk/9L7b+RXup6pK0n+qPdn5KkkDyR5edczrack9yU5m+Spl6y9OsnDSZ7pfb5mEI9lwPv3IvDhqnoDcBPwgSRv7Himrt0JnOx6iBHxl8DXquqXgDexQZ+XJJPAHwLTVfXLwCbgd7udat19DrjlsrW7gEeq6gbgkd7Xa2bA+1RVZ6rqid7tF1j8A9rtezZ1KMn1wG8Cn+16lq4l+TngrcC9AFX1f1U13+1UndoMjCXZDLwCON3xPOuqqh4DfnDZ8q3Aod7tQ8CeQTyWAV+FJNuBKeDxbifp1F8Afwz8qOtBRsAvAHPAX/e2lD6b5JVdD9WFqpoFPg58DzgD/FdVfb3bqUbCdVV1BhZfDAKvGcQvNeArlORVwBeBD1XVD7uepwtJfgs4W1XHup5lRGwG3gx8uqqmgP9hQH9Fbk1vb/dW4HXANuCVSX6v26muXgZ8BZJsYTHe91fV4a7n6dAu4LeTPAt8Hnh7kr/pdqROPQc8V1UX/kb2IItB34jeAfxbVc1V1TngMPCrHc80Cp5PshWg9/nsIH6pAe9TkrC4x3myqj7Z9Txdqqr9VXV9VW1n8QDVN6pqw77Kqqr/AP49yYW3G78Z+HaHI3Xpe8BNSV7R+zNzMxv0gO5lvgzc3rt9O/DQIH6pb2rcv13A+4ATSZ7srX2kqr7a4UwaHX8A3J/kZ4DvAL/f8TydqKrHkzwIPMHimVvH2WCX1Cd5AHgbcG2S54CPAvcAX0hyB4v/k3vPQB7LS+klqU1uoUhSowy4JDXKgEtSowy4JDXKgEtSowy4JDXKgEtSo/4fvwiO356q/MYAAAAASUVORK5CYII=\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.scatter(x, y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "P = lambda V: modelo(V, popt)/popt\n",
    "mod = [P(i) for i in x]\n",
    "exp = y"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
